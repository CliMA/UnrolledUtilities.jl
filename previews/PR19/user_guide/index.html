<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · UnrolledUtilities.jl</title><meta name="title" content="User Guide · UnrolledUtilities.jl"/><meta property="og:title" content="User Guide · UnrolledUtilities.jl"/><meta property="twitter:title" content="User Guide · UnrolledUtilities.jl"/><meta name="description" content="Documentation for UnrolledUtilities.jl."/><meta property="og:description" content="Documentation for UnrolledUtilities.jl."/><meta property="twitter:description" content="Documentation for UnrolledUtilities.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="UnrolledUtilities.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="UnrolledUtilities.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Introduction</a></li><li class="is-active"><a class="tocitem" href>User Guide</a><ul class="internal"><li><a class="tocitem" href="#When-to-Use-Unrolled-Functions"><span>When to Use Unrolled Functions</span></a></li><li><a class="tocitem" href="#When-to-Use-StaticOneTo-and-StaticBitVector"><span>When to Use <code>StaticOneTo</code> and <code>StaticBitVector</code></span></a></li></ul></li><li><a class="tocitem" href="../developer_guide/">Developer Guide</a></li><li><a class="tocitem" href="../comparison_tables/">Comparison Tables</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/UnrolledUtilities.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/UnrolledUtilities.jl/blob/main/docs/src/user_guide.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="When-to-Use-UnrolledUtilities"><a class="docs-heading-anchor" href="#When-to-Use-UnrolledUtilities">When to Use UnrolledUtilities</a><a id="When-to-Use-UnrolledUtilities-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-UnrolledUtilities" title="Permalink"></a></h1><p>The functions and types exported by this package tend to perform better than their counterparts from <code>Base</code> and <code>Base.Iterators</code> in the scenarios listed below. Additional examples and more precise measurements can be found in the automatically generated <a href="../comparison_tables/">tables of benchmarks</a>.</p><h5 id="Outline:"><a class="docs-heading-anchor" href="#Outline:">Outline:</a><a id="Outline:-1"></a><a class="docs-heading-anchor-permalink" href="#Outline:" title="Permalink"></a></h5><ul><li><a href="#When-to-Use-Unrolled-Functions">When to Use Unrolled Functions</a></li><li class="no-marker"><ul><li><a href="#Long-iterators">Long iterators</a></li><li><a href="#Iterators-with-elements-of-different-types">Iterators with elements of different types</a></li><li><a href="#Reduction-operations-with-non-constant-return-types">Reduction operations with non-constant return types</a></li><li><a href="#Operations-with-more-than-2-levels-of-recursion">Operations with more than 2 levels of recursion</a></li></ul></li><li><a href="#When-to-Use-StaticOneTo-and-StaticBitVector">When to Use <code>StaticOneTo</code> and <code>StaticBitVector</code></a></li><li class="no-marker"><ul><li><a href="#Iterators-of-Ints-from-1-to-N">Iterators of <code>Int</code>s from 1 to <code>N</code></a></li><li><a href="#Long-iterators-of-Bools-that-get-modified-across-loop-iterations">Long iterators of <code>Bool</code>s that get modified across loop iterations</a></li></ul></li></ul><h2 id="When-to-Use-Unrolled-Functions"><a class="docs-heading-anchor" href="#When-to-Use-Unrolled-Functions">When to Use Unrolled Functions</a><a id="When-to-Use-Unrolled-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-Unrolled-Functions" title="Permalink"></a></h2><h3 id="Long-iterators"><a class="docs-heading-anchor" href="#Long-iterators">Long iterators</a><a id="Long-iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Long-iterators" title="Permalink"></a></h3><ul><li><p><code>map</code> has an unstable return type for iterators with lengths greater than 32:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Test.@inferred map(one, Tuple(1:31));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Test.@inferred map(one, Tuple(1:32));</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: return type NTuple{32, Int64} does not match inferred return type Tuple</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Test.@inferred unrolled_map(one, Tuple(1:32));</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre></li><li><p><code>getindex</code> has an unstable return type for <code>Core.Const</code> slices of length <code>N &gt; 10</code> from iterators with lengths greater than <code>N + 2</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; first_11(itr) = itr[1:11]</code><code class="nohighlight hljs ansi" style="display:block;">first_11 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Test.@inferred first_11(Tuple(1:13));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Test.@inferred first_11(Tuple(1:14));</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: return type NTuple{11, Int64} does not match inferred return type Tuple{Vararg{Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; unrolled_first_11(itr) = unrolled_take(itr, Val(11))</code><code class="nohighlight hljs ansi" style="display:block;">unrolled_first_11 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Test.@inferred unrolled_first_11(Tuple(1:14));</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre></li><li><p>For benchmarks that indicate performance improvements when using unrolled functions with long iterators, see <a href="../comparison_tables/#Isolated-Unrolled-Functions">Isolated Unrolled Functions</a></p></li></ul><h3 id="Iterators-with-elements-of-different-types"><a class="docs-heading-anchor" href="#Iterators-with-elements-of-different-types">Iterators with elements of different types</a><a id="Iterators-with-elements-of-different-types-1"></a><a class="docs-heading-anchor-permalink" href="#Iterators-with-elements-of-different-types" title="Permalink"></a></h3><ul><li><p><code>in</code> has an intermediate type instability that triggers allocations for nonuniform iterators:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated () in ((1, 2), (1, 2, 3))</code><code class="nohighlight hljs ansi" style="display:block;">32</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated unrolled_in((), ((1, 2), (1, 2, 3)))</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre></li><li><p><code>any</code>, <code>all</code>, and <code>foreach</code> have intermediate type instabilities that trigger allocations for nonuniform iterators with lengths greater than 32:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const nonuniform_itr_of_length_32 = (ntuple(Returns((1, 2)), 31)..., (1, 2, 3));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; const nonuniform_itr_of_length_33 = (ntuple(Returns((1, 2)), 32)..., (1, 2, 3));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated any(isempty, nonuniform_itr_of_length_32)</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated any(isempty, nonuniform_itr_of_length_33)</code><code class="nohighlight hljs ansi" style="display:block;">1024</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated unrolled_any(isempty, nonuniform_itr_of_length_33)</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre></li><li><p><code>getindex</code> has an unstable return type for nonuniform iterators when given non-constant (i.e., not <code>Core.Const</code>) indices, which can lead to intermediate type instabilities that trigger allocations:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function add_lengths(itr)
           length_sum = 0
           for n in 1:length(itr)
               length_sum += length(itr[n])
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">add_lengths (generic function with 1 method)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated add_lengths(((1, 2), (1, 2, 3)))</code><code class="nohighlight hljs ansi" style="display:block;">64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function unrolled_add_lengths(itr)
           length_sum = 0
           for n in 1:length(itr)
               length_sum += unrolled_applyat(length, n, itr)
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">unrolled_add_lengths (generic function with 1 method)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated unrolled_add_lengths(((1, 2), (1, 2, 3)))</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><h5><em>How can <code>unrolled_applyat</code> be stable if <code>n</code> isn&#39;t a <code>Core.Const</code>?</em></h5><p>For the example of <code>add_lengths</code>, the compiler must infer the return type of <code>itr[::Int64]</code> before it can compile the call to <code>length</code>. Since this return type depends on the index <code>n</code>, the compiler needs to insert a runtime lookup into the method table that determines which method of <code>length</code> to call, <code>length(::Tuple{Int64, Int64})</code> or <code>length(::Tuple{Int64, Int64, Int64})</code>, and this triggers allocations.</p><p>For the example of <code>unrolled_add_lengths</code>, the compiler instead infers the return types of <code>itr[::Core.Const(1)]</code>, <code>itr[::Core.Const(2)]</code>, and so on for every index into <code>itr</code>. Then, it compiles a call to <code>length</code> for each of these return types, and it inserts a runtime <a href="https://llvm.org/docs/LangRef.html#switch-instruction">switch instruction</a> that determines which result of <code>length</code> to return for a particular value of <code>n</code>. As long as <code>length</code> itself only returns one type (in this case, <code>Int64</code>), this ensures that <code>unrolled_add_lengths</code> has no intermediate type instabilities.</p><p>In other words, <code>unrolled_applyat</code> combines multiple methods for <code>length</code> and <code>getindex</code> into a single method, replacing the inefficient method table lookup that switches between them with a simpler switch instruction.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><h5><em>When should <code>getindex</code> be replaced with <code>unrolled_applyat</code>?</em></h5><p>The specific example above could be simplified by using <code>mapreduce</code>, instead of using a <code>for</code>-loop in conjunction with <code>unrolled_applyat</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated mapreduce(length, +, ((1, 2), (1, 2, 3)))</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>However, there are often situations in which it is not possible to replace loops with function calls, like when those loops are parallelized over CPU or GPU threads. Moreover, CUDA is unable to compile any kernels with type instabilities that trigger allocations, so <code>unrolled_applyat</code> is <em>required</em> in order to parallelize over nonuniform iterators on GPUs.</p></div></div></li><li><p>For benchmarks that indicate performance improvements when using unrolled functions with nonuniform iterators, see <a href="../comparison_tables/#Isolated-Unrolled-Functions">Isolated Unrolled Functions</a> and <a href="../comparison_tables/#Nested-Unrolled-Functions">Nested Unrolled Functions</a></p></li></ul><h3 id="Reduction-operations-with-non-constant-return-types"><a class="docs-heading-anchor" href="#Reduction-operations-with-non-constant-return-types">Reduction operations with non-constant return types</a><a id="Reduction-operations-with-non-constant-return-types-1"></a><a class="docs-heading-anchor-permalink" href="#Reduction-operations-with-non-constant-return-types" title="Permalink"></a></h3><ul><li><p><code>reduce</code> and <code>accumulate</code> have unstable return types when the return type of <code>op</code> is not constant, but only for iterator lengths greater than 32:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Test.@inferred reduce(tuple, Tuple(1:32));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Test.@inferred reduce(tuple, Tuple(1:33));</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: return type Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Tuple{Int64, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64}, Int64} does not match inferred return type Union{Int64, Tuple{Any, Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Test.@inferred unrolled_reduce(tuple, Tuple(1:33));</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre></li><li><p>For benchmarks that indicate performance improvements when using unrolled functions with nonuniform reductions, see <a href="../comparison_tables/#Isolated-Unrolled-Functions">Isolated Unrolled Functions</a></p></li></ul><h3 id="Operations-with-more-than-2-levels-of-recursion"><a class="docs-heading-anchor" href="#Operations-with-more-than-2-levels-of-recursion">Operations with more than 2 levels of recursion</a><a id="Operations-with-more-than-2-levels-of-recursion-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-with-more-than-2-levels-of-recursion" title="Permalink"></a></h3><ul><li><p>All functions in Julia have a default &quot;recursion limit&quot; of 2; unless this limit is modified, it forces any function that recursively calls itself 2 or more times to have an unstable return type:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; recursive_length(itr) =
           eltype(itr) &lt;: Tuple ? mapreduce(recursive_length, +, itr) : length(itr)</code><code class="nohighlight hljs ansi" style="display:block;">recursive_length (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Test.@inferred recursive_length(((1, 2), (1, 2, 3)));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Test.@inferred recursive_length((((1,), (2,)), (1, 2, 3)));</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: return type Int64 does not match inferred return type Any</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; unrolled_recursive_length(itr) =
           eltype(itr) &lt;: Tuple ?
           unrolled_mapreduce(unrolled_recursive_length, +, itr) : length(itr)</code><code class="nohighlight hljs ansi" style="display:block;">unrolled_recursive_length (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Test.@inferred unrolled_recursive_length((((1,), (2,)), (1, 2, 3)));</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><h5><em>Is there any other way to avoid the default recursion limit?</em></h5><p>The default recursion limit applies to all functions defined in <code>Base</code> and <code>Base.Iterators</code>, so those functions will have unstable return types for more than 2 levels of recursion, even when all user-defined functions passed to them have had their recursion limits disabled. It is also impossible to modify the recursion limits of functions defined in <code>Base</code> from external packages. This means that the only way to avoid the default recursion limit is to not use certain functions from <code>Base</code>, and instead to define alternatives without any recursion limits.</p></div></div></li><li><p>For benchmarks that indicate performance improvements when using unrolled functions with recursive operations, see <a href="../comparison_tables/#Recursive-Unrolled-Functions">Recursive Unrolled Functions</a></p></li></ul><h2 id="When-to-Use-StaticOneTo-and-StaticBitVector"><a class="docs-heading-anchor" href="#When-to-Use-StaticOneTo-and-StaticBitVector">When to Use <code>StaticOneTo</code> and <code>StaticBitVector</code></a><a id="When-to-Use-StaticOneTo-and-StaticBitVector-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-StaticOneTo-and-StaticBitVector" title="Permalink"></a></h2><h3 id="Iterators-of-Ints-from-1-to-N"><a class="docs-heading-anchor" href="#Iterators-of-Ints-from-1-to-N">Iterators of <code>Int</code>s from 1 to <code>N</code></a><a id="Iterators-of-Ints-from-1-to-N-1"></a><a class="docs-heading-anchor-permalink" href="#Iterators-of-Ints-from-1-to-N" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnrolledUtilities.StaticOneTo" href="#UnrolledUtilities.StaticOneTo"><code>UnrolledUtilities.StaticOneTo</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StaticOneTo(N)</code></pre><p>A lazy and statically sized analogue of <code>Base.OneTo(N)</code>.</p><p>This iterator can only store the integers from 1 to <code>N</code>, so its <code>output_type_for_promotion</code> is <code>NoOutputType()</code>. An efficient method is provided for <code>unrolled_take</code>, but no other unrolled functions can use <code>StaticOneTo</code>s as output types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/UnrolledUtilities.jl/blob/7307b78b6b1c73471179c368b46dadf1d769acde/src/StaticOneTo.jl#L1-L10">source</a></section></article><p>If an iterator only contains the integers from 1 to <code>N ≥ 0</code>, it is possible to provide the compiler with the values in the iterator in addition to their types by using a <code>StaticOneTo</code>, as opposed to a <code>Tuple</code> or something similar. This can allow the compiler to fully optimize out code that depends on those values, essentially moving the code&#39;s execution from run time to compilation time:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_llvm debuginfo=:none mapreduce(abs2, +, (1, 2, 3))</code><code class="nohighlight hljs ansi" style="display:block;">define i64 @julia_mapreduce_29408([3 x i64]* nocapture noundef nonnull readonly align 8 dereferenceable(24) %0) #0 {
top:
  %1 = getelementptr inbounds [3 x i64], [3 x i64]* %0, i64 0, i64 0
  %2 = getelementptr inbounds [3 x i64], [3 x i64]* %0, i64 0, i64 1
  %3 = getelementptr inbounds [3 x i64], [3 x i64]* %0, i64 0, i64 2
  %unbox = load i64, i64* %1, align 8
  %4 = mul i64 %unbox, %unbox
  %unbox2 = load i64, i64* %2, align 8
  %5 = mul i64 %unbox2, %unbox2
  %6 = add i64 %5, %4
  %unbox4 = load i64, i64* %3, align 8
  %7 = mul i64 %unbox4, %unbox4
  %8 = add i64 %6, %7
  ret i64 %8
}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_llvm debuginfo=:none mapreduce(abs2, +, StaticOneTo(3))</code><code class="nohighlight hljs ansi" style="display:block;">define i64 @julia_mapreduce_29430() #0 {
top:
  ret i64 14
}</code></pre><p>Standard library functions can sometimes take advantage of this optimization, but for most non-trivial operations it is necessary to use unrolled functions:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_llvm debuginfo=:none mapreduce(log, +, StaticOneTo(3))</code><code class="nohighlight hljs ansi" style="display:block;">define double @julia_mapreduce_29442() #0 {
top:
  %0 = call double @j__log_29444(double 2.000000e+00, {}* inttoptr (i64 140385746298248 to {}*))
  %1 = fadd double %0, 0.000000e+00
  %2 = call double @j__log_29444(double 3.000000e+00, {}* inttoptr (i64 140385746298248 to {}*))
  %3 = fadd double %1, %2
  ret double %3
}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_llvm debuginfo=:none unrolled_mapreduce(log, +, StaticOneTo(3))</code><code class="nohighlight hljs ansi" style="display:block;">define double @julia_unrolled_mapreduce_29449() #0 {
top:
  ret double 0x3FFCAB0BFA2A2002
}</code></pre><p>For benchmarks that indicate performance improvements when using <code>StaticOneTo</code>s, see <a href="../comparison_tables/#Very-Long-Iterators">Very Long Iterators</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><h5><em>Can the compiler infer iterator values in other scenarios?</em></h5><p>The compiler can usually infer the values of iterators that only contain <a href="https://docs.julialang.org/en/v1/manual/types/#man-singleton-types">singletons</a> when they are accessed using <code>Core.Const</code> indices, but this is not possible for non-singletons (e.g., integers) unless some special type of iterator is used (e.g., a <code>StaticOneTo</code>).</p></div></div><h3 id="Long-iterators-of-Bools-that-get-modified-across-loop-iterations"><a class="docs-heading-anchor" href="#Long-iterators-of-Bools-that-get-modified-across-loop-iterations">Long iterators of <code>Bool</code>s that get modified across loop iterations</a><a id="Long-iterators-of-Bools-that-get-modified-across-loop-iterations-1"></a><a class="docs-heading-anchor-permalink" href="#Long-iterators-of-Bools-that-get-modified-across-loop-iterations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnrolledUtilities.StaticBitVector" href="#UnrolledUtilities.StaticBitVector"><code>UnrolledUtilities.StaticBitVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StaticBitVector{N, [U]}(f)
StaticBitVector{N, [U]}([bit])</code></pre><p>A statically sized analogue of <code>BitVector</code> with <code>Unsigned</code> chunks of type <code>U</code>, which can be constructed using either a function <code>f(n)</code> or a constant <code>bit</code>. By default, <code>U</code> is set to <code>UInt8</code> and <code>bit</code> is set to <code>false</code>.</p><p>This iterator can only store <code>Bool</code>s, so its <code>output_type_for_promotion</code> is a <code>ConditionalOutputType</code>. Efficient implementations are provided for all unrolled functions, though the methods for <code>unrolled_map</code> and <code>unrolled_accumulate</code> only apply when the first item in the output is a <code>Bool</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/UnrolledUtilities.jl/blob/7307b78b6b1c73471179c368b46dadf1d769acde/src/StaticBitVector.jl#L1-L13">source</a></section></article><p>Loops in Julia often allocate memory when a value larger than 32 bytes in size is modified across loop iterations (regardless of whether the loops are unrolled or not). Since <code>Bool</code>s are represented by bytes, this limits certain types of loops to modifying <a href="https://en.wikipedia.org/wiki/Mask_(computing)">bitmasks</a> of no more than 32 <code>Bool</code>s in order to avoid allocations. Unlike an iterator of <code>Bool</code>s, though, a <code>StaticBitVector</code> stores 8 bits in every byte, which makes it possible to modify up to 256 bits at a time in loops without any allocations:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; random_bit_flips(itr) = reduce(
           (itr′, i) -&gt; Base.setindex(itr′, !itr′[rand(1:i)], i),
           1:length(itr);
           init = itr,
       )</code><code class="nohighlight hljs ansi" style="display:block;">random_bit_flips (generic function with 1 method)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated random_bit_flips(ntuple(Returns(true), Val(32)))</code><code class="nohighlight hljs ansi" style="display:block;">0</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated random_bit_flips(ntuple(Returns(true), Val(33)))</code><code class="nohighlight hljs ansi" style="display:block;">4224</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated random_bit_flips(StaticBitVector{256}(true))</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>As with <code>StaticOneTo</code>s, standard library functions can occasionally optimize <code>StaticBitVector</code>s as well as unrolled functions, but most complex use cases require unrolled functions.</p><p>For benchmarks that indicate performance improvements when using long <code>StaticBitVector</code>s that get modified across loop iterations, see <a href="../comparison_tables/#Nested-Unrolled-Closures">Nested Unrolled Closures</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../introduction/">« Introduction</a><a class="docs-footer-nextpage" href="../developer_guide/">Developer Guide »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 22 October 2024 20:16">Tuesday 22 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
